<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>技术栈指北</title>
      <link href="/2020/05/24/%E6%8A%80%E6%9C%AF%E6%A0%88%E6%8C%87%E5%8C%97/"/>
      <url>/2020/05/24/%E6%8A%80%E6%9C%AF%E6%A0%88%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>作为一个crud boy，想要在当今国内的互联网环境下安身立命，避免跳槽时力有不逮，各类技术都需要掌握娴熟，知其然也知其所以然。</p><p>想着如果日后不懒惰，写一片片技术笔记，也最好有个目录可供参考，感觉博客自带的tags和categories显得略微杂乱。</p><h3 id="1-java"><a class="markdownIt-Anchor" href="#1-java"></a> 1. Java</h3><h4 id="11-effective-java-3rd"><a class="markdownIt-Anchor" href="#11-effective-java-3rd"></a> 1.1 Effective-Java-3rd</h4><p>Effective-Java-3rd 的学习笔记</p><h3 id="2-数据库"><a class="markdownIt-Anchor" href="#2-数据库"></a> 2. 数据库</h3><h4 id="21-mysql"><a class="markdownIt-Anchor" href="#21-mysql"></a> 2.1 MySQL</h4><h4 id="22-redis"><a class="markdownIt-Anchor" href="#22-redis"></a> 2.2 Redis</h4><h3 id="3-springboot"><a class="markdownIt-Anchor" href="#3-springboot"></a> 3. SpringBoot</h3><h3 id="4-数据持久层框架"><a class="markdownIt-Anchor" href="#4-数据持久层框架"></a> 4. 数据持久层框架</h3><h4 id="41-mybatis"><a class="markdownIt-Anchor" href="#41-mybatis"></a> 4.1 Mybatis</h4><h3 id="5-rpc-框架"><a class="markdownIt-Anchor" href="#5-rpc-框架"></a> 5. RPC 框架</h3><h4 id="51-dubbo"><a class="markdownIt-Anchor" href="#51-dubbo"></a> 5.1 Dubbo</h4><h3 id="6-依赖配置与构建工具"><a class="markdownIt-Anchor" href="#6-依赖配置与构建工具"></a> 6. 依赖配置与构建工具</h3><h4 id="61-gradle"><a class="markdownIt-Anchor" href="#61-gradle"></a> 6.1 Gradle</h4><h3 id="7-设计模式"><a class="markdownIt-Anchor" href="#7-设计模式"></a> 7. 设计模式</h3>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java可变长度参数</title>
      <link href="/2020/04/16/Java%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%8F%82%E6%95%B0/"/>
      <url>/2020/04/16/Java%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>Java中的可变长度参数使用三个点表示，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vaTest</span><span class="params">(<span class="keyword">int</span> ... v)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"Number of Args: "</span> + v.length + <span class="string">" Contents: "</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x: v)</span><br><span class="line">        System.out.print(x + <span class="string">" "</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然较为简单，但是也存在一些容易造成编译失败的问题，即方法重载造成的模糊性问题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vaTest</span><span class="params">(<span class="keyword">int</span> ...v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vaTest</span><span class="params">(<span class="keyword">boolean</span> .. v)</span></span>;</span><br></pre></td></tr></table></figure><p>对于上述定义的方法，若代码中出现<code>vaTest()</code>等空参数调用，则由于调用的含糊不清，会编译失败。</p><p>类似地如下代码，也存在模糊性问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vaTest</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> ...v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vaTest</span><span class="params">(<span class="keyword">int</span> ...v)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多态中方法的优先级</title>
      <link href="/2020/04/16/Java%E5%A4%9A%E6%80%81%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2020/04/16/Java%E5%A4%9A%E6%80%81%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>OOP三大特性之一的多态</p><blockquote><p>就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。(Ref：<a href="https://www.cnblogs.com/chenssy/p/3372798.html" target="_blank" rel="noopener">博客</a>)</p></blockquote><p>在子类继承父类的过程中，经常存在Override的情况，这也是多态的体现，然而在具体代码执行过程中，由于“向上转型”的操作，Override方法执行的优先级，是一个需要注意的问题。</p><p>先看一段经典的代码，对应输出已给出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(D obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(B obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"B and B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"B and A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritChain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> B();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        D d = <span class="keyword">new</span> D();</span><br><span class="line">        System.out.println(a1.show(b)); <span class="comment">// A and A</span></span><br><span class="line">        System.out.println(a1.show(c)); <span class="comment">// A and A</span></span><br><span class="line">        System.out.println(a1.show(d)); <span class="comment">// A and D</span></span><br><span class="line">        System.out.println(a2.show(b)); <span class="comment">// B and A</span></span><br><span class="line">        System.out.println(a2.show(c)); <span class="comment">// B and A</span></span><br><span class="line">        System.out.println(a2.show(d)); <span class="comment">// A and D</span></span><br><span class="line">        System.out.println(b.show(b));  <span class="comment">// B and B</span></span><br><span class="line">        System.out.println(b.show(c));  <span class="comment">// B and B</span></span><br><span class="line">        System.out.println(b.show(d));  <span class="comment">// A and D</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个与第二个，因为定义的是一个A类，而A类中没有<code>show(B obj)</code>与<code>show(C obj)</code>方法，而B C都可以视作A的子类，因此会输出<strong>A and A</strong>，同理第三个也容易理解。</p><p>第四个，直观地我们会认为应该输出<strong>B and B</strong>，因为我们初始化的是一个B类的实例，虽然向上转型，但是应该执行B类的<code>show(B obj)</code>方法，但这种理解是错误的，这就涉及到继承中方法执行优先级的问题。</p><p>首先明确两点：</p><ul><li><p>当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，<strong>但是这个被调用的方法必须是在超类中定义过的</strong>(Ref：<a href="https://www.jianshu.com/p/976eec24d9d7" target="_blank" rel="noopener">博客</a>)</p><ul><li>当超类引用子类对象时，调用的方法必须在超类中定义过；</li><li><strong>引用对象</strong>的类型而不是<strong>引用变量</strong>的类型决定了，调用谁的成员方法</li></ul></li><li><p>继承链中的方法调用优先级，总结来说就是<strong>this.show(O) ——&gt; super.show(O) ——&gt; this.show((super)O) ——&gt; super.show((super)O)</strong>；</p></li></ul><p>基于上述两点，我们可以对上面的输出做出解释：</p><ul><li><p>1/2/3 都不存在超类对象引用子类变量的问题，容易理解；</p></li><li><p><code>a2.show(b)</code>：</p><ul><li>a2变量在调用<code>show(B obj)</code>时，虽然a2引用的是B类的对象，但是由于A类中不存在<code>show(B obj)</code>方法，因此不能直接调用B类中的<code>show(B obj)</code>方法，**this.show(O)**失败；</li><li>同理，A类中不存在<code>show(B obj)</code>方法，**super.show(O)**失败；</li><li>进入<strong>this.show(super(O))</strong>，B是A的子类，因此此时执行的是<code>B.show(A)</code>，最终输出<strong>B and A</strong></li></ul></li><li><p><code>a2.show(c)</code>；</p><ul><li>B类中不存在<code>show(C obj)</code>方法，**this.show(O)**失败；</li><li><strong>super.show(O)</strong>，即<code>A.show(C)</code>，A类中不存在<code>show(C obj)</code>方法，失败；</li><li><strong>this.show(super(O))</strong>，即<code>B.show(B)</code>，但由于A类中不存在<code>show(B obj)</code>方法，因此，哪怕B类中存在<code>show(B obj)</code>方法，也不能执行，失败；</li><li><strong>super.show(super(O))</strong>，即<code>A.show(B)</code>，由于B是A的子类，因此会调用<code>A.show(A)</code>，但又由于B重写了<code>show(A obj)</code>方法，因此会调用<code>B.show(A)</code>，最后输出<strong>B and A</strong></li></ul></li><li><p><code>a2.show(d)</code></p></li><li><p>B类中不存在<code>show(D obj)</code>方法，因此**this.show(O)**失败；</p></li><li><p>直接执行<code>A.show(D)</code>，即输出<strong>A and D</strong>；</p></li></ul><p>其他的同理可推倒。</p><p>一般来说，很多文章都会给出<strong>this.show(O) ——&gt; super.show(O) ——&gt; this.show((super)O) ——&gt; super.show((super)O)</strong>，这样一条优先级链条，但仅凭这样一条链条，就容易把<code>a2.show(B)</code>的输出预判为<strong>B and B</strong>。因为经常忽视掉的就是，前面所说两点中的第一点，即<strong>当超类引用子类对象时，调用的方法必须在超类中定义过</strong>，结合这两点才能判断正确的执行过程。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Polymorphism </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Stream初探</title>
      <link href="/2020/04/10/Java-Stream/"/>
      <url>/2020/04/10/Java-Stream/</url>
      
        <content type="html"><![CDATA[<p>这里简单地对Java中Stream的两类基本类做个记录，具体平时会使用的类的功能，后续再学习记录。</p><h3 id="1-流的概念"><a class="markdownIt-Anchor" href="#1-流的概念"></a> 1. “流”的概念</h3><blockquote><p>“流”是一个抽象的概念，它是对输入输出设备的一种抽象理解，在Java中，对数据的输入输出操作都是以“流”的方式进行的。“流”具有方向性，<strong>输入流、输出流是相对的</strong>。当程序需要从数据源中读入数据的时候就会开启一个输入流，相反，写出数据到某个数据源目的地的时候也会开启一个输出流。数据源可以是文件、内存或者网络等。（Ref：<a href="https://blog.csdn.net/liji_xc/java/article/details/47291075" target="_blank" rel="noopener">博客</a>）</p></blockquote><h3 id="2-流的分类"><a class="markdownIt-Anchor" href="#2-流的分类"></a> 2. 流的分类</h3><p>有几种不同的分类方法（Ref：<a href="https://www.zhihu.com/question/28457447/answer/260699828" target="_blank" rel="noopener">知乎</a>）：</p><ul><li><p>按方向分：输入流、输出流；</p></li><li><p>按处理数据的不同分：字节流、字符流；</p><ul><li><p>字节流：处理的基本单位为<strong>单个字节</strong>（1 byte)</p></li><li><p>字符流：处理的基本单位为<strong>Unicode 码元</strong>（2 bytes）</p></li></ul></li><li><p>按所属功能分：节点流、处理流</p><ul><li><blockquote><p>节点流是直接从一个源读写数据的流（这个流没有经过包装和修饰），处理流是在对节点流封装的基础上的 一种流，FileInputStream是一个节点流，可以直接从文件读取数据，但是BufferedInputStream可以包装 FileInputStream，使得其有缓冲功能</p></blockquote></li></ul></li></ul><h3 id="3-字节流与字符流"><a class="markdownIt-Anchor" href="#3-字节流与字符流"></a> 3. 字节流与字符流</h3><h4 id="31-字节流"><a class="markdownIt-Anchor" href="#31-字节流"></a> 3.1 字节流</h4><blockquote><p>Java中的字节流处理的最基本单位为单个字节，它通常用来处理二进制数据。</p></blockquote><p>Java中字节流的两个最基本的类是<strong>InputStream</strong>与<strong>OutputStream</strong>，两个均为抽象类，其中包含的具体方法见官方文档，目前Java14相较于Java8添加了很多新方法。下面都以Java8为例，对两个抽象类做简单介绍。</p><h5 id="311-inputstream"><a class="markdownIt-Anchor" href="#311-inputstream"></a> 3.1.1 InputStream</h5><p><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener"><strong>InputStream</strong></a>有包括<strong>ByteArrayInputStream</strong>、<strong>FileInputStream</strong>等在内的多个子类，用于不同的数据源中读取数据。在sun.net包中，也包括<strong>TelnetInputStream</strong>等用于从网络连接中读取数据的子类。</p><p><strong>InputStream</strong>提供了将数据读取为原始字节所需的基本方法，首先包含3个读方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>第一个抽象方法<code>read()</code>是<strong>InputStream</strong>的基本方法，任何子类都需要实现该方法。第二个<code>read(byte b[])</code>源码中实际上调用了第三个<code>read(byte b[], int off, int len)</code>方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;Java</span><br><span class="line">&#x2F;**</span><br><span class="line">Reads the next byte of data from the input stream. The value byte is returned as an &lt;code&gt;int&lt;&#x2F;code&gt; in the range &lt;code&gt;0&lt;&#x2F;code&gt; to &lt;code&gt;255&lt;&#x2F;code&gt;. If no byte is available because the end of the stream has been reached, the value &lt;code&gt;-1&lt;&#x2F;code&gt; is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>即<code>read()</code>一次只从字节流中取一个字节，直到结束，同时具有阻塞功能。第二三个read方法看似有缓冲功能，实际上也是调用了<code>read()</code>方法，并无法缓冲。</p><p><strong>关于InputStream下BufferedInputStream等的缓冲功能的详细原理，这里先不思考了。</strong></p><h5 id="312-outputstream"><a class="markdownIt-Anchor" href="#312-outputstream"></a> 3.1.2 OutputStream</h5><p>相比<strong>InputStream</strong>，<strong>OutputStream</strong>较为简单，只有五个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException；</span></span><br></pre></td></tr></table></figure><p><strong>OutputStream</strong>的子类，使用这些方法，向特定介质中写入数据。如，<strong>FileOutputStream</strong>将数据写入文件，<strong>TelnetOutputStream</strong>将数据写入网络连接。</p><p><strong>OuputStream</strong>的基本方法<code>write(int b)</code>将传入的int参数的低阶8位（eigth low-order bits）作为字节写入，高阶24位被忽略，即真正能有效传入的int参数，范围在0<sub>255之间。一些有问题的第三方类在写入超过0</sub>255的值时，有可能会报<strong>IllegalArgumentException</strong>的异常，或者总是写入255，因此，尽可能避免写入不在0~255范围之内的数字。</p><p>若输出流存在缓冲区，若不及时进行刷新（flush）操作，有可能导致输出流不能及时将数据输出，<code>flush()</code>方法可以强迫缓冲的流发送数据，即使缓冲区还未填满，而且flush操作成本较低，因此一般情况下，最好在写完数据后执行flush操作。</p><p>当结束一个流的操作后，需要调用<code>close()</code>方法将其关闭，释放其使用的文件句柄和端口。Java7后，引入了“带资源的try”（try with resources），否则使用finally语句时，还要先检测输出流是否为NULL。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">    OutputStream out1 = <span class="keyword">new</span> FileOutputSteram(<span class="string">"path1"</span>);</span><br><span class="line">    OutputStream out2 = <span class="keyword">new</span> FileOutputSteram(<span class="string">"path2"</span>);</span><br><span class="line">    ) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        System.err.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 try-with-resources 语句中，也可以声明多个资源，各资源声明语句用分号隔开，当从<code>try</code>块中（以正常或异常方式）退出时，在 try-with-resources 语句中所声明资源的关闭方法都会被自动调用，并且是按与资源声明序相反的顺序调用其<code>close()</code>方法的。(Ref:<a href="https://blog.csdn.net/clxjoseph/article/details/50637426" target="_blank" rel="noopener">博客</a>)</p></blockquote><h4 id="32-字符流"><a class="markdownIt-Anchor" href="#32-字符流"></a> 3.2 字符流</h4><blockquote><p>Java中的字符流处理的最基本的单元是Unicode码元（大小2字节）。</p></blockquote><p>Java中字符流的两个基本类是<strong>Reader</strong>与<strong>Writer</strong>，与字节流中的<strong>InputStream</strong>与<strong>OutputStream</strong>一样，这两个类也不直接使用，而是使用且各个子类。</p><h5 id="321-reader"><a class="markdownIt-Anchor" href="#321-reader"></a> 3.2.1 Reader</h5><p>类似于<strong>InputStream</strong>，<strong>Reader</strong>包括多个<code>read()</code>方法，与<code>skip()</code>、<code>reset()</code>等方法，但其中包含两个基本方法是子类必须实现的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Reads characters into a portion of an array.  This method will block until some input is available, an I/O error occurs, or the end of the stream is reached.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Closes the stream and releases any system resources associated with it.  Once the stream has been closed, further read(), ready(), mark(), reset(), or skip() invocations will throw an IOException. Closing a previously closed stream has no effect.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><h5 id="322-writer"><a class="markdownIt-Anchor" href="#322-writer"></a> 3.2.2 Writer</h5><p>主要包括<code>write()</code>, <code>append()</code>, <code>flush()</code>, <code>close()</code>几个方法，子类需要实现的抽象方法包括：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Stream </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test-file2</title>
      <link href="/2020/03/23/test-file2/"/>
      <url>/2020/03/23/test-file2/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="you can try again" data-whm="testsfas">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">input password(if you know)</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="c7175f5bbfd684c2d02a2bbb016e5152a160ac85edb0ed2ed67a19992c191635">3227678b60e953a4efefeddb02aea3730a2f32610d8bd21c4c2d010d98f95ae58fc8e1dae2347e053876e9b9109fd49d875e735dc8bdc16a071ed08a620f2233fe15cbcaddad8a17415be0c86a4292de3963acac5f5024f88562ad6f16471eab21b7008b65fa23a9f606d51dcc230c63506f5f77c81cce6cacaff1e3c392c8a4428d4b058d163acec990a257252f1f67a855e82a4ea85044b6233dd6c3416acdbb47dff0f15bd3ad4bc267997ce45edf50e5ff12dda7f3a4395fc58213c0b8272d2b10e210ac43b14f6ba7a3d3e06e4d5b42c6324380661e505015062ff73812cb82c603956e9b443adc5757dac536fb9f682c15f5811e53ad7f63ddf0d2b7d909cd72b4eac535735e8ee722da48bbe1872bf47b6cc5f78a897edced0fe9dedc4c50261f1647ee83530c4ceb753dfc8876e17a819b03a385664453ee180e5c4135d0477403a75ec13cdc170a4888512e569b3a4427d5603c0fdf789ceeca7dd9fad953a66b741170766833f929bd7300772c022590041298241249ac8331e7f4e65b7ed98ef9414656134778880857fe9894fc3ba780402fd69be8436babac84b82f024dd12ca23d4ebb9331ef20a9de4a8a3feb25327aef758b008a1a0cf2ee23c0bac78586cc7734d1de1d3240a4c601edb91a39415937ec0cc12e523d97b9b61be44200b47c82c5865634ffaa7833fa12dfb5176bbc01037a8d9f6906b6ff3eb21e711fe9f329f81f84dc39db8a7b3ebb4d08f452d70a085ede649a4f83834e9f83e8185269899285c8b7b5c39e4973f3e5a1972ee9fcbe98a2452a392c6b6750a2ee19b470a64ce20c1fdf01f96bac855ebeb56848ffab8094bf451ca81db9a197b7f10c616cc0de96dfb8ed8d27929d2e724da8ce7fd82d5dc5f4ad593d4109dd3b8ad3534fb42d9d23d6f0b714c9b9dc5220714ac25954ab8bcc32b4d3f54028608d3a70b117666b6a2b6c044b4b8d6abb50ab2704ba4c74ed4b1816173c2d7d23f7080a982a7607a92d022ac4338f13aaef0b986250c1a96bd73115d9709e6c19ee6b79e0410517699b2ab993c92e7f1823dd58d5ab5eeedbe983a62cc3191f17e6dfbc0becbf4ad27a6b1ffced37d0f9b9994dc75678b161217c475f443d730b14c6117ee3cd8a096ef849634a5f935b504a237fbe8b9d645f10567abc170cba766b32b3dda2415f85a5e9c009e4b016e67d1ebbaf5d3a9512dc715f01a6a81ea7c8adff71389ef52092a3de76e8ef68ffdd8db4183f29a01fde9b4c48364a18480b5d3ad627f7b03fe161552bdb939e5563ac6ab3de4b81c984c2926a29f06037f95e9fb118d3f92c7e53f1bd974779672382a4125aa3633935ee7348ab9dd37ef69ad8050aed77304b30fbfd1bcf1e65003aa4a63b70d312dbe28e306753b1503463e37875cfd78c8de859960bf663c3f1fe3d3401ae9443cd54a9c326fb4d80483c6147c893f761168b9c0fe37a49f08aa0beb6dd38b77d83fe7583e44484de4b3e43ac3737bde103685074b27995dd6432576ea2757c7e658da3a463714bc23728a151a0fed8e2a0841090df44615a8b0c3ecc0fb49b9a36d44d4f1a5f35044eb92a9b80490ec6e4be57183be0a9b4226de055d99f1bcd8ee4d2a77ba91a1c6434883a1673a8feb02a0604a2fe443a00267ccecfd4766ba536ad693cfc6e056e4b67a3312110e8aa59c1ff473887cf68332803eaabf0e3c52b72c1c300a12506a1813ba97fb46434f1e70f49f27e00de105ddac15736c996f76353a059456a00255663953bd24908b10e0531ae137ca97d88d2f0fa59127f1dcfecb8091b2db9c26f98d966efd77b30582e5ad56819eef22e4cb38d7d91c02b50a334aad4c79532e2a61d94fbe69ec19fc3d0be23f5accd40a36ca73b166f21038fb11c75a6ae1bf03c8409736c73216fd44c2076c50de5b63f78602fae5a5b7a1936f20ed4e262438497b969dc2d73cf22f85736c0025540b3fa9370c070f73c1c31b1be4e62bdb504d0f48cb8d73b104f549cce4a401eb39082d3620d4d31beb69b7b7a02eef8dda84b7d7840568970f1217d2be6abe29ffcdbc436e8bdf9914652f26cdd643be69bc7ad0aa09beeff94124a701a81954a971c77095ef50836c321c67b5566c99c01e4d3ed4f48e708f25c1df215ade63c3d4c98696b5caa1c8009e5853a4344d87062ecfbdcbcdb742ae464740a9a6c4c9a317c7743aea5b7c63735b36fba28fe0a8ec9952e10a521a5719e98a2870cea391f5d4c0a7160f25806e16ac5d2ff94e88886083ecc9abd1cf2e17fb0d0789e8acc16943148e20a1a54bdc93cbe5fd7c2f8365e3369d74b9dc9e32d9f1520952cd3dc3ad964cdf7364eeb15540c652f318202f3ac455e6b02df4f61b9b8986cd89c9ea2cffc0ba2fb89dc19584fe3ae9e576e86edfdf7d1d1a8a8066d597d003a0cdc9fd576a8766196b9e32d93ef7c295f371b12a2c9c2f126c0e533fd65086b15ffcf566b2520b3d70da388a170ebf09eb92aa4adc42f4f4207ddb687cd164559e274146f129b5b75d44e152bdbdb1af9a2d20776e124ebb8ea1e2f9b71ccdcaf81747b582b15bcac7179c6195a5c9c9d0c0992cfaf5fb017d8078b56781ee710e797fbceb0f31eecf1450d9a6dc5e79a13faade96a90e29aa9a1696b523fc0019a82741dc89dc36fb2b1973fd6abd685d611ad1b1f5b0b731d6666731b5e5f5a245f4f87b600fa70a0af1640878f8d1ebe2fdce47dc765bf1184add65b11b93128fb2874b3d82467de9efad64e0b46324ae1bb83d8675fa2c4153b1cb519b59d5df3e1056317ab872e3f8e6af0eeb1694a6473e9a0e081c3e87534cb38b8e18cde68995adfce7bd8a0ea2715d8eb725f72e8a7a0d6511cd1e375e56ef63b90940b730636a90a9f3971dae0d6d0c43fc4cf583e171c07bf42b936270d66e360109a1c88a189fc3da337e80f7cd8a7bc167fcac32bc1e20b540c6003aee7775a3904730eb7480708c5e271ba30161cf7ddc92dd83db711bc87b196914f4ae825ac05e2430296df13050fd793b3de9fa147f231861de95986f454d96e099395856d39eac7937f9c4a7b44e421ad68abfdc0b8f086247476f5473b1462026a503fbe0b4199f3ee4d44cd3802d31c6fdf19c23bb67e78edc1114a81fc320760f11b4330054b2efc8447423eb64faef8ae1fedaa29eb79fe7d9805be4502c2db7282331de50d1b9157af4df67800d49b3fc4755f2541620d99d7fc13ff9b7114709b5b6a646e7dc6a3a7fc388d883295d1bdb5c884cd6d3a6a0506cd2c0c9195aa6e61a56e886ee95ae1a54a9ee5cde01d9ec261c6b70f1a6ae7ad5d31e712614952184c7e11bcbcaaf211602a8d58eda93f0488f8dddaa881f3e4bbbacb61369c2938a1945775bbede9881eca124e2a4217d4b5daed995f5e9ab0e4126c17e15f4648c08054c6671940775d572216f74764b44fb756ad293c9644326c972fdfccc18d2ccb64e2a77e1dc41219f7e5acbe263eeb0e378cddf72edea7d70e0ea4f645e825015ff2d9a80a127bb005a5e395863cc567fa6e01b4831dacb7ee7ad02979c95412569b293dc69c524bd36a1f1d0a4eda1fddb1eed2b4f7ec7f774c337118bf679a84e031913c488b1c7738049e9ad93a47cf288573ea51329c0e79cccec21901e6b76862399273b207dac2f022c68293d6750cff6fa609d72c02688891bba38a7a1a8404c41f8f0554a073064448817e49cf9f8fce4e8652cf32292b545ee3c24a1e18b696f9445e048a2714e03eb645545f322b9fab756e35e95494334a17acf547c082df35a482f1bde9e3afcfbc92698dcc7144550b461b4616f7ae49afd571a2d7424e9aece39c3a8595371b4467a373a589c18937b80d1abc20ef7b281a505ed39b8d03b04e65e7550c79f13c401eb9a42dcb24f11565e405b14ccdcca4a44345a17eaf1fb3bd1e429b1472a3679e25f2b548e0521c595d527c36ab4b845023091e5b70f9424f58dd5d0d770e3f7a0a747edfa4a111180d685481fa49fca1045fb1ec21b507e87387001e2e0a67d84a308e82a536c3d9fa8cbd30fc33f37bb6ec880ebbdb54f72cbd02133a93abc813610337bd0e066e19e145caab188f4001534e7f7bbe0c327d77b766ca8b67b59fe8e0b05dd783aa2914b6d41029eef7507ee7aead735b4ae9a9032d3de1cc3111b2b2287232e74c3ca28704c6a5990aa1fa28681a88a5c92871cf7bc533cd95ab9a33bee05666d46aa95367c962effa01d7cf6449e77d5b355380d77571592a4681c8569d77b27d7e928eb09c17c8aea55ae63ad35e033aa3f2e29e59a7490bad55ca618491e236a6fd4978ed812ad6b7e25ec2718eda6742635c21dddc6e317cd5af08b89ccf52f33a095760f974fed47ca1fa13c0cb138582df18b90c17c2da52df3f32483329f98155916955b0c27ccd857cfb3def78f8c5ce77b408e073bc6f8f4889daa40ca5c2ebd6d43dce0709eb1142593f859928d481ec3179cf9704b514acd4b6292d2a08b71fd5bb22f99d70e9827832562d392ac8c61d873d3baba37466657ad772e069a48da9e753dd5b1d40361303e5c1321d19858d9b3e0494123487c250ffe8b36f9c5ab5d1bf59745afd8c4ae629f263c03454aad5b4af4478229acd8b87324cdc83bd186086183d1dbff4444c75614eb71b27f568231f91c0f47cc7763b3e4ff26730d263ac704624b0d21f06ad1754f96d79a72b994ecd8dbfd2f3297daa02bf46816e8832be0c2fdecf1c75117ae37ecbeb8bf1037b03b955b1e33c8610b112bd7a6c6c4239d66d47d03b453d14867141e165f64110082494a6ef49127703db8e4dacc7f501659968b6a402d95d88a55fc2917cc3bc6bedd861f99b724e09a2c2f4291043d5876660f12814292acbe1d87ef2277be54c5e28c8bdab818bcfa93bd9eee5dd2452732e09c5779456aad694c7ee684225a6aebeb8550a37d64a846b41a3021292cf663ea923a616f57863c8b77129fe054bbabaf235984cab53269ac6a85b4dedcf44d2235dd0957fea6b54374b109cdf103120e107750ce16c444470ecba79526929ebde389756e7bae2f16694244ca1498aa0d61a4a74b24e5ccccbd0c461edb94cdd2422b2b6e1b7b077cc2f00b0a033b88ee2fba1f17578bc070a27289e8dc797f64908f7f0b45a4a0dc49fc9f54c8e76d36b7d35bc99921d1e50fc3740ea70470291238016ce704df4dfcc286ae841d30f2772c5b88477c54af3f7067d9094c5bec28d86e35edc74bc747da765b106402a62e54c8848fb9a81079c9ef0fb2bdb53f5180f9f98512da0ff8692f28efc645f7fec885eda39b01d9d9e3b076127f421315b91833097e1cbc7d6c7053f0a9663ff69dbe3e16d2651ec66a1a5d707dd4dc4b6ec39d1e492c2e76e997da77fe014f31057bb626ac3fc1c2100964b642c90583ad360e62ff65c55915018602a658cf2c8b29fa484ef8f5383567a05eaa393b81a8012d2002fbba2e7bfc21bb01cf15935dba0f564edfd2b80edc00d929299a7a82a12d9e30424ccc5f4d63a278ba1ce2ddfddc598736d74585dddbc6258a6bb3d6e684a218e2f03cb09657fda1b6e3f53e345ff6163faf4c13447b9bc251cadaec20be1f1e9089699439216f945de8266f2249f4666dafeb2a83f6511f4c41bd88a1fd0d1e15e7bea8c095234898eb72e38f1639024dc3afafb2e52ff71c4c63e9b20c2f6b47f9b67d922c9014babf431a30fd9c5d67acc0c1876256d843854f11e828029c453a638814e005705ddfde61a9c3e68ed19db4e227d73543a15b70336741e37c38234a1391f387f8048d5a9bd73078645793a96a8ca0644787e4269c2284cd498cf8969c04729f969e09d0756957d3b1ad74c287a643bd6c6d75acc66624581162ca422846d05019a9a7f7ae559eca2688a39f3ea0c0d9077a723c3df0a68fd221f1e35c9165942a8dd3d6adb7e25bdd811929a294f0f44dd5451952fcd72ab986a51f7b7a43305e01d22fc2aca4f027d197bcc08ab4b79954d48</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> test1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tag1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test File</title>
      <link href="/2020/03/22/test-file/"/>
      <url>/2020/03/22/test-file/</url>
      
        <content type="html"><![CDATA[<h3 id="1-阅读全文测试"><a class="markdownIt-Anchor" href="#1-阅读全文测试"></a> 1. 阅读全文测试</h3><p>凑够50个字<br />下过大雨，你来看看葡萄园吧，那叫好看！白的像白玛瑙，红的像红宝石，紫的像紫水晶，黑的像黑玉。一串一串，饱满、磁棒、挺括，璀璨琳琅。你就把《说文解字》里的玉字偏旁的字都搬了来吧，那也不够用呀！</p><a id="more"></a><h3 id="2-tagcategories-test"><a class="markdownIt-Anchor" href="#2-tagcategories-test"></a> 2. Tag&amp;Categories Test</h3><p>上面</p><h4 id="21-多及目录测试"><a class="markdownIt-Anchor" href="#21-多及目录测试"></a> 2.1 多及目录测试</h4><p>test测试阿凡达付所付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付付</p><h3 id="3-会自动添加date吗"><a class="markdownIt-Anchor" href="#3-会自动添加date吗"></a> 3. 会自动添加date吗</h3><p>会的</p><h3 id="关闭评论"><a class="markdownIt-Anchor" href="#关闭评论"></a> 关闭评论</h3><p>会的</p><h3 id="代码展示测试"><a class="markdownIt-Anchor" href="#代码展示测试"></a> 代码展示测试</h3><p>python code</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ___name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"AI"</span>)</span><br></pre></td></tr></table></figure><p>java code</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pack</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fancybox"><a class="markdownIt-Anchor" href="#fancybox"></a> fancybox</h3><p><img src="https://s1.ax1x.com/2020/03/23/8TgJAJ.gif" alt="img1" /><br /><img src="https://s1.ax1x.com/2020/03/23/8TgYN9.gif" alt="img2" /></p>]]></content>
      
      
      <categories>
          
          <category> TestCate1 </category>
          
          <category> TestCate2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TestTag1 </tag>
            
            <tag> TestTag2 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
